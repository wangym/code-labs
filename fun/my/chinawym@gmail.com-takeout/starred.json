{
  "id" : "user/06079683711886564499/state/com.google/starred",
  "title" : "Google 阅读器中 Yumin 加注星标的条目",
  "author" : "Yumin",
  "updated" : 1361875763,
  "direction" : "ltr",
  "items" : [ {
    "isReadStateLocked" : true,
    "crawlTimeMsec" : "1361875763277",
    "timestampUsec" : "1361875763277046",
    "id" : "tag:google.com,2005:reader/item/34173156a96fc3c8",
    "categories" : [ "user/06079683711886564499/state/com.google/starred", "user/06079683711886564499/state/com.google/read", "编程" ],
    "title" : "非线程安全的HashMap 和 线程安全的ConcurrentHashMap",
    "published" : 1294975997,
    "updated" : 1294975997,
    "alternate" : [ {
      "href" : "http://blog.sina.com.cn/s/blog_4a1f59bf0100o98k.html",
      "type" : "text/html"
    } ],
    "summary" : {
      "direction" : "ltr",
      "content" : "<p>\n在平时开发中，我们经常采用HashMap来作为本地缓存的一种实现方式，将一些如系统变量等数据量比较少的参数保存在HashMap中，并将其作\n为单例类的一个属性。在系统运行中，使用到这些缓存数据，都可以直接从该单例中获取该属性集合。但是，最近发现，HashMap并不是线程安全的，如果你\n的单例类没有做代码同步或对象锁的控制，就可能出现异常。<br>\n<br>\n首先看下在多线程的访问下，非现场安全的HashMap的表现如何，在网上看了一些资料，自己也做了一下测试：<br></p>\n<div style=\"border:1px solid rgb(204,204,204);padding:4px 5px 4px 4px;font-size:13px;width:98%;background-color:rgb(238,238,238)\">\n<span style=\"color:rgb(0,128,128)\"> 1</span><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_23_869_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedBlock.gif\" align=\"top\" name=\"Codehighlighter1_23_869_Closed_Image\"><span style=\"color:rgb(0,0,255)\">public</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">class</span><span style=\"color:rgb(0,0,0)\"> MainClass </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\"> 2</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">    <br>\n</span><span style=\"color:rgb(0,128,128)\"> 3</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">    </span><span style=\"color:rgb(0,0,255)\">public</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">static</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">final</span><span style=\"color:rgb(0,0,0)\"> HashMap</span><span style=\"color:rgb(0,0,0)\">&lt;</span><span style=\"color:rgb(0,0,0)\">String, String</span><span style=\"color:rgb(0,0,0)\">&gt;</span><span style=\"color:rgb(0,0,0)\"> firstHashMap</span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,255)\">new</span><span style=\"color:rgb(0,0,0)\"> HashMap</span><span style=\"color:rgb(0,0,0)\">&lt;</span><span style=\"color:rgb(0,0,0)\">String, String</span><span style=\"color:rgb(0,0,0)\">&gt;</span><span style=\"color:rgb(0,0,0)\">();<br>\n</span><span style=\"color:rgb(0,128,128)\"> 4</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">    <br>\n</span><span style=\"color:rgb(0,128,128)\"> 5</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_186_866_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_186_866_Closed_Image\">    </span><span style=\"color:rgb(0,0,255)\">public</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">static</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">void</span><span style=\"color:rgb(0,0,0)\"> main(String[] args) </span><span style=\"color:rgb(0,0,255)\">throws</span><span style=\"color:rgb(0,0,0)\"> InterruptedException </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\"> 6</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        <br>\n</span><span style=\"color:rgb(0,128,128)\"> 7</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,128,0)\">//</span><span style=\"color:rgb(0,128,0)\">线程一</span><span style=\"color:rgb(0,128,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\"> 8</span><span style=\"color:rgb(0,128,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_223_349_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_223_349_Closed_Image\"></span><span style=\"color:rgb(0,0,0)\">        Thread t1</span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,255)\">new</span><span style=\"color:rgb(0,0,0)\"> Thread()</span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\"> 9</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_246_345_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_246_345_Closed_Image\">            </span><span style=\"color:rgb(0,0,255)\">public</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">void</span><span style=\"color:rgb(0,0,0)\"> run() </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\">10</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_273_340_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_273_340_Closed_Image\">                </span><span style=\"color:rgb(0,0,255)\">for</span><span style=\"color:rgb(0,0,0)\">(</span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> i</span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\">0</span><span style=\"color:rgb(0,0,0)\">;i</span><span style=\"color:rgb(0,0,0)\">&lt;</span><span style=\"color:rgb(0,0,0)\">25</span><span style=\"color:rgb(0,0,0)\">;i</span><span style=\"color:rgb(0,0,0)\">++</span><span style=\"color:rgb(0,0,0)\">)</span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\">11</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">                    firstHashMap.put(String.valueOf(i), String.valueOf(i));<br>\n</span><span style=\"color:rgb(0,128,128)\">12</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">                }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">13</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">            }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">14</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">        }</span></span><span style=\"color:rgb(0,0,0)\">;<br>\n</span><span style=\"color:rgb(0,128,128)\">15</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        <br>\n</span><span style=\"color:rgb(0,128,128)\">16</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,128,0)\">//</span><span style=\"color:rgb(0,128,0)\">线程二</span><span style=\"color:rgb(0,128,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">17</span><span style=\"color:rgb(0,128,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_387_514_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_387_514_Closed_Image\"></span><span style=\"color:rgb(0,0,0)\">        Thread t2</span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,255)\">new</span><span style=\"color:rgb(0,0,0)\"> Thread()</span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\">18</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_410_510_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_410_510_Closed_Image\">            </span><span style=\"color:rgb(0,0,255)\">public</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">void</span><span style=\"color:rgb(0,0,0)\"> run() </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\">19</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_438_505_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_438_505_Closed_Image\">                </span><span style=\"color:rgb(0,0,255)\">for</span><span style=\"color:rgb(0,0,0)\">(</span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> j</span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\">25</span><span style=\"color:rgb(0,0,0)\">;j</span><span style=\"color:rgb(0,0,0)\">&lt;</span><span style=\"color:rgb(0,0,0)\">50</span><span style=\"color:rgb(0,0,0)\">;j</span><span style=\"color:rgb(0,0,0)\">++</span><span style=\"color:rgb(0,0,0)\">)</span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\">20</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">                    firstHashMap.put(String.valueOf(j), String.valueOf(j));<br>\n</span><span style=\"color:rgb(0,128,128)\">21</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">                }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">22</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">            }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">23</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">        }</span></span><span style=\"color:rgb(0,0,0)\">;<br>\n</span><span style=\"color:rgb(0,128,128)\">24</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        <br>\n</span><span style=\"color:rgb(0,128,128)\">25</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        t1.start();<br>\n</span><span style=\"color:rgb(0,128,128)\">26</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        t2.start();<br>\n</span><span style=\"color:rgb(0,128,128)\">27</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        <br>\n</span><span style=\"color:rgb(0,128,128)\">28</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,128,0)\">//</span><span style=\"color:rgb(0,128,0)\">主线程休眠1秒钟，以便t1和t2两个线程将firstHashMap填装完毕。</span><span style=\"color:rgb(0,128,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">29</span><span style=\"color:rgb(0,128,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\"></span><span style=\"color:rgb(0,0,0)\">        Thread.currentThread().sleep(</span><span style=\"color:rgb(0,0,0)\">1000</span><span style=\"color:rgb(0,0,0)\">);<br>\n</span><span style=\"color:rgb(0,128,128)\">30</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        <br>\n</span><span style=\"color:rgb(0,128,128)\">31</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_658_860_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_658_860_Closed_Image\">        </span><span style=\"color:rgb(0,0,255)\">for</span><span style=\"color:rgb(0,0,0)\">(</span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> l</span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\">0</span><span style=\"color:rgb(0,0,0)\">;l</span><span style=\"color:rgb(0,0,0)\">&lt;</span><span style=\"color:rgb(0,0,0)\">50</span><span style=\"color:rgb(0,0,0)\">;l</span><span style=\"color:rgb(0,0,0)\">++</span><span style=\"color:rgb(0,0,0)\">)</span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\">32</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">            </span><span style=\"color:rgb(0,128,0)\">//</span><span style=\"color:rgb(0,128,0)\">如果key和value不同，说明在两个线程put的过程中出现异常。</span><span style=\"color:rgb(0,128,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">33</span><span style=\"color:rgb(0,128,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_768_856_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_768_856_Closed_Image\"></span><span style=\"color:rgb(0,0,0)\">            </span><span style=\"color:rgb(0,0,255)\">if</span><span style=\"color:rgb(0,0,0)\">(</span><span style=\"color:rgb(0,0,0)\">!</span><span style=\"color:rgb(0,0,0)\">String.valueOf(l).equals(firstHashMap.get(String.valueOf(l))))</span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\">34</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">                System.err.println(String.valueOf(l)</span><span style=\"color:rgb(0,0,0)\">+</span><span style=\"color:rgb(0,0,0)\">\"</span><span style=\"color:rgb(0,0,0)\">:</span><span style=\"color:rgb(0,0,0)\">\"</span><span style=\"color:rgb(0,0,0)\">+</span><span style=\"color:rgb(0,0,0)\">firstHashMap.get(String.valueOf(l)));<br>\n</span><span style=\"color:rgb(0,128,128)\">35</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">            }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">36</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">        }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">37</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        <br>\n</span><span style=\"color:rgb(0,128,128)\">38</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">    }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">39</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\"><br></span><span style=\"color:rgb(0,128,128)\">40</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockEnd.gif\" align=\"top\">}</span></span></div>\n<br>\n上面的代码在多次执行后，发现表现很不稳定，有时没有异常文案打出，有时则有个异常出现：<br>\n<img alt=\"\" src=\"http://www.blogjava.net/images/blogjava_net/lukangping/20100905.GIF\" border=\"0\"><br>\n<br>\n为什么会出现这种情况，主要看下HashMap的实现：<br>\n<div style=\"border:1px solid rgb(204,204,204);padding:4px 5px 4px 4px;font-size:13px;width:98%;background-color:rgb(238,238,238)\">\n<span style=\"color:rgb(0,128,128)\"> 1</span><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_29_581_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedBlock.gif\" align=\"top\" name=\"Codehighlighter1_29_581_Closed_Image\"><span style=\"color:rgb(0,0,255)\">public</span><span style=\"color:rgb(0,0,0)\"> V put(K key, V value) </span><span><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\"> 2</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">    </span><span style=\"color:rgb(0,0,255)\">if</span><span style=\"color:rgb(0,0,0)\"> (key </span><span style=\"color:rgb(0,0,0)\">==</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">null</span><span style=\"color:rgb(0,0,0)\">)<br>\n</span><span style=\"color:rgb(0,128,128)\"> 3</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,0,255)\">return</span><span style=\"color:rgb(0,0,0)\"> putForNullKey(value);<br>\n</span><span style=\"color:rgb(0,128,128)\"> 4</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> hash </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> hash(key.hashCode());<br>\n</span><span style=\"color:rgb(0,128,128)\"> 5</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> i </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> indexFor(hash, table.length);<br>\n</span><span style=\"color:rgb(0,128,128)\"> 6</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_231_494_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_231_494_Closed_Image\">        </span><span style=\"color:rgb(0,0,255)\">for</span><span style=\"color:rgb(0,0,0)\"> (Entry</span><span style=\"color:rgb(0,0,0)\">&lt;</span><span style=\"color:rgb(0,0,0)\">K,V</span><span style=\"color:rgb(0,0,0)\">&gt;</span><span style=\"color:rgb(0,0,0)\"> e </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> table[i]; e </span><span style=\"color:rgb(0,0,0)\">!=</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">null</span><span style=\"color:rgb(0,0,0)\">; e </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> e.next) </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\"> 7</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">            Object k;<br>\n</span><span style=\"color:rgb(0,128,128)\"> 8</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_328_484_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_328_484_Closed_Image\">            </span><span style=\"color:rgb(0,0,255)\">if</span><span style=\"color:rgb(0,0,0)\"> (e.hash </span><span style=\"color:rgb(0,0,0)\">==</span><span style=\"color:rgb(0,0,0)\"> hash </span><span style=\"color:rgb(0,0,0)\">&amp;&amp;</span><span style=\"color:rgb(0,0,0)\"> ((k </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> e.key) </span><span style=\"color:rgb(0,0,0)\">==</span><span style=\"color:rgb(0,0,0)\"> key </span><span style=\"color:rgb(0,0,0)\">||</span><span style=\"color:rgb(0,0,0)\"> key.equals(k))) </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\"> 9</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">                V oldValue </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> e.value;<br>\n</span><span style=\"color:rgb(0,128,128)\">10</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">                e.value </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> value;<br>\n</span><span style=\"color:rgb(0,128,128)\">11</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">                e.recordAccess(</span><span style=\"color:rgb(0,0,255)\">this</span><span style=\"color:rgb(0,0,0)\">);<br>\n</span><span style=\"color:rgb(0,128,128)\">12</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">                </span><span style=\"color:rgb(0,0,255)\">return</span><span style=\"color:rgb(0,0,0)\"> oldValue;<br>\n</span><span style=\"color:rgb(0,128,128)\">13</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">            }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">14</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">        }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\">15</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\"><br></span><span style=\"color:rgb(0,128,128)\">16</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        modCount</span><span style=\"color:rgb(0,0,0)\">++</span><span style=\"color:rgb(0,0,0)\">;<br>\n</span><span style=\"color:rgb(0,128,128)\">17</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        addEntry(hash, key, value, i);<br>\n</span><span style=\"color:rgb(0,128,128)\">18</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,0,255)\">return</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">null</span><span style=\"color:rgb(0,0,0)\">;<br>\n</span><span style=\"color:rgb(0,128,128)\">19</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockEnd.gif\" align=\"top\">    }</span></span></div>\n<br>\n我觉得问题主要出现在方法addEntry，继续看：<br>\n<div style=\"border:1px solid rgb(204,204,204);padding:4px 5px 4px 4px;font-size:13px;width:98%;background-color:rgb(238,238,238)\">\n<span style=\"color:rgb(0,128,128)\">1</span><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_57_236_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedBlock.gif\" align=\"top\" name=\"Codehighlighter1_57_236_Closed_Image\"><span style=\"color:rgb(0,0,255)\">void</span><span style=\"color:rgb(0,0,0)\"> addEntry(</span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> hash, K key, V value, </span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> bucketIndex) </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\">2</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">    Entry</span><span style=\"color:rgb(0,0,0)\">&lt;</span><span style=\"color:rgb(0,0,0)\">K,V</span><span style=\"color:rgb(0,0,0)\">&gt;</span><span style=\"color:rgb(0,0,0)\"> e </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> table[bucketIndex];<br>\n</span><span style=\"color:rgb(0,128,128)\">3</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        table[bucketIndex] </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">new</span><span style=\"color:rgb(0,0,0)\"> Entry</span><span style=\"color:rgb(0,0,0)\">&lt;</span><span style=\"color:rgb(0,0,0)\">K,V</span><span style=\"color:rgb(0,0,0)\">&gt;</span><span style=\"color:rgb(0,0,0)\">(hash, key, value, e);<br>\n</span><span style=\"color:rgb(0,128,128)\">4</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,0,255)\">if</span><span style=\"color:rgb(0,0,0)\"> (size</span><span style=\"color:rgb(0,0,0)\">++</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,0)\">&gt;=</span><span style=\"color:rgb(0,0,0)\"> threshold)<br>\n</span><span style=\"color:rgb(0,128,128)\">5</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">            resize(</span><span style=\"color:rgb(0,0,0)\">2</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,0)\">*</span><span style=\"color:rgb(0,0,0)\"> table.length);<br>\n</span><span style=\"color:rgb(0,128,128)\">6</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockEnd.gif\" align=\"top\">    }</span></span></div>\n<br>\n从代码中，可以看到，如果发现哈希表的大小超过阀值threshold，就会调用resize方法，扩大容量为原来的两倍，而扩大容量的做法是新建一个\nEntry[]：<br>\n<div style=\"border:1px solid rgb(204,204,204);padding:4px 5px 4px 4px;font-size:13px;width:98%;background-color:rgb(238,238,238)\">\n<span style=\"color:rgb(0,128,128)\"> 1</span><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_29_391_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedBlock.gif\" align=\"top\" name=\"Codehighlighter1_29_391_Closed_Image\"><span style=\"color:rgb(0,0,255)\">void</span><span style=\"color:rgb(0,0,0)\"> resize(</span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> newCapacity) </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\"> 2</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        Entry[] oldTable </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> table;<br>\n</span><span style=\"color:rgb(0,128,128)\"> 3</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        </span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\"> oldCapacity </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> oldTable.length;<br>\n</span><span style=\"color:rgb(0,128,128)\"> 4</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif\" align=\"top\" name=\"Codehighlighter1_153_226_Open_Image\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ContractedSubBlock.gif\" align=\"top\" name=\"Codehighlighter1_153_226_Closed_Image\">        </span><span style=\"color:rgb(0,0,255)\">if</span><span style=\"color:rgb(0,0,0)\"> (oldCapacity </span><span style=\"color:rgb(0,0,0)\">==</span><span style=\"color:rgb(0,0,0)\"> MAXIMUM_CAPACITY) </span><span style=\"border:1px solid rgb(128,128,128);background-color:rgb(255,255,255)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/dot.gif\"></span><span><span style=\"color:rgb(0,0,0)\">{<br></span><span style=\"color:rgb(0,128,128)\"> 5</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">            threshold </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> Integer.MAX_VALUE;<br>\n</span><span style=\"color:rgb(0,128,128)\"> 6</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">            </span><span style=\"color:rgb(0,0,255)\">return</span><span style=\"color:rgb(0,0,0)\">;<br>\n</span><span style=\"color:rgb(0,128,128)\"> 7</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif\" align=\"top\">        }</span></span><span style=\"color:rgb(0,0,0)\"><br>\n</span><span style=\"color:rgb(0,128,128)\"> 8</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\"><br></span><span style=\"color:rgb(0,128,128)\"> 9</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        Entry[] newTable </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> </span><span style=\"color:rgb(0,0,255)\">new</span><span style=\"color:rgb(0,0,0)\"> Entry[newCapacity];<br>\n</span><span style=\"color:rgb(0,128,128)\">10</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        transfer(newTable);<br>\n</span><span style=\"color:rgb(0,128,128)\">11</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        table </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> newTable;<br>\n</span><span style=\"color:rgb(0,128,128)\">12</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif\" align=\"top\">        threshold </span><span style=\"color:rgb(0,0,0)\">=</span><span style=\"color:rgb(0,0,0)\"> (</span><span style=\"color:rgb(0,0,255)\">int</span><span style=\"color:rgb(0,0,0)\">)(newCapacity </span><span style=\"color:rgb(0,0,0)\">*</span><span style=\"color:rgb(0,0,0)\"> loadFactor);<br>\n</span><span style=\"color:rgb(0,128,128)\">13</span><span style=\"color:rgb(0,0,0)\"><img alt=\"\" src=\"http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockEnd.gif\" align=\"top\">    }</span></span></div>\n<br>\n一般我们声明HashMap时，使用的都是默认的构造方法：HashMap&lt;K,V&gt;，看了代码你会发现，它还有其它的构造方法：<font style=\"background-color:rgb(204,232,204)\">HashMap(int\ninitialCapacity, float loadFactor)</font>，其中参数initialCapacity为初始容\n量，loadFactor为加载因子，而之前我们看到的<font style=\"background-color:rgb(204,232,204)\">threshold = (int)(capacity\n* loadFactor);</font>\n如果在默认情况下，一个HashMap的容量为16，加载因子为0.75，那么阀值就是12，所以在往HashMap中put的值到达12时，它将自动扩\n容两倍，如果两个线程同时遇到HashMap的大小达到12的倍数时，就很有可能会出现在将oldTable转移到newTable的过程中遇到问题，从\n而导致最终的HashMap的值存储异常。<br>\n<br>\nJDK1.0引入了第一个关联的集合类HashTable，<font color=\"#333333\" face=\"Arial\">它是线程安全的。 HashTable的所有方法都是同步的。<br>\nJDK2.0引入了HashMap，它提供了一个不同步的基类和一个同步的包装器synchronizedMap。synchronizedMap被称为\n有条件的线程安全类。<br>\nJDK5.0util.concurrent包中引入对Map线程安全的实现ConcurrentHashMap，比起synchronizedMap，\n它提供了更高的灵活性。同时进行的读和写操作都可以并发地执行。<br>\n<br>\n所以在开始的测试中，如果我们采用ConcurrentHashMap，它的表现就很稳定，所以以后如果使用Map实现本地缓存，为了提高并发时的稳定\n性，还是建议使用ConcurrentHashMap。<br>\n<br>\n<br>\n====================================================================<br>\n\n<br>\n另外，还有一个我们经常使用的ArrayList也是非线程安全的，网上看到的有一个解释是这样：<br>\n一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2.\n增大 Size 的值。<br>\n在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；<br>\n而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B\n得到运行的机会。线程B也将元素放在位置0，（因为size还未增长），完了之后，两个线程都是size++，结果size变成2，而只有\nitems[0]有元素。<br>\nutil.concurrent包也提供了一个线程安全的ArrayList替代者CopyOnWriteArrayList。<br>\n<br>\n本文转载自：http://www.blogjava.net/lukangping/articles/331089.html<br></font><div style=\"border-top:1px solid rgb(203,217,217);padding-top:20px;padding-bottom:10px\"> \n<p><br><a href=\"http://move.blog.sina.com.cn/msnmove/index.php\">MSN空间完美搬家到新浪博客!</a></p></div>"
    },
    "author" : "klose",
    "comments" : [ ],
    "annotations" : [ ],
    "origin" : {
      "streamId" : "feed/http://blog.sina.com.cn/rss/1243568575.xml",
      "title" : "klose的BLOG",
      "htmlUrl" : "http://blog.sina.com.cn/jiangbinglover"
    }
  }, {
    "isReadStateLocked" : true,
    "crawlTimeMsec" : "1361875729886",
    "timestampUsec" : "1361875729886992",
    "id" : "tag:google.com,2005:reader/item/f4618499f2c9fbfd",
    "categories" : [ "user/06079683711886564499/state/com.google/starred", "user/06079683711886564499/state/com.google/read", "编程" ],
    "title" : "Java并发编程总结---Hadoop核心源码实例解读",
    "published" : 1306377764,
    "updated" : 1306377764,
    "alternate" : [ {
      "href" : "http://blog.sina.com.cn/s/blog_4a1f59bf0100sg8t.html",
      "type" : "text/html"
    } ],
    "summary" : {
      "direction" : "ltr",
      "content" : "<br>\n<font style=\"font-size:18px;font-weight:bold\">程序设计需要同步(synchronization),原因：</font><br>\n\n1）复杂的功能要求的需要使用多线程编程，线程之间存在读写共享变量。<br>\n2）读写共享变量(shared mutual variable),JVM的内存模型(Memory model: decide when\nand how changes made by one thread become visuble to\nothers)受到其它因素干扰。<br>\n3）对共享变量的操作非原子性。例如 i++;就不是原子操作，它分为两部分,（1） 读i （2）\ni+1写入内存。如果i是线程A和线程B共享的变量，线程A在操作（1）之后，线程调度器调度调度线程B执行i++，因此两个线程在变量i产生了不一致。注意，volatile修饰符是线程操作之前更新数据，但是，上面的问题显然不是更新数据就能解决的。<br>\n\n4）增加互斥区(mutual\nexclusion)会降低执行效率，但是这是实现数据安全、功能强大的多线程编程最为重要的部分。<br>\n5）线程之间需要配合的场景需要并发控制逻辑。<br>\n<font style=\"font-size:18px;font-weight:bold\"><br>\nJava并发编程使用的方法：</font><br>\n<br>\n1） 为代码块和函数添加synchronized，同步的作用有两点：<br>\n<pre style=\"padding:1em;border:1px dashed rgb(47,111,171);color:black;background-color:rgb(249,249,249);line-height:1.1em\">\n\n(1)a means of mutual exclusion, to prevent an object from being observed in an inconsistent\nstate while it’s being modified by another thread.<br>\n<br>\n(2)guarantee that one thread’s changes will be visible to another<br>\n</pre>\n2）配合使用object的wait和notify，实现对象monitor控制权从一个线程调度到另外一个线程。具体实例请参阅http://blog.sina.com.cn/s/blog_4a1f59bf0100rgxh.html<br>\n\n3）使用ReentrantLock和Condition控制。ReentrantLock和Condition出现在java.util.concurrent包中。下面有从Hadoop源码中摘取出来的一部分的内容作为介绍。<br>\n\n<br>\n<font style=\"font-size:20px;font-weight:bold\">Hadoop源码使用并发控制的实例：<br></font>Map阶段产生&lt;K,V&gt;会先存储在内存中，等到io.sort.mb指定的内存达到阈值(percent)时，会启动spill到本地磁盘的工作。<br>\n\nReentrantLock与Condition的配合使用，Condition为ReentrantLock锁的等待和释放提供控制逻辑。<br>\n\n例如，使用ReentrantLock加锁之后，可以通过它自身的Condition.await()方法释放该锁，线程在此等待Condition.signal()方法，然后继续执行下去。await方法需要放在while循环中，因此，在不同线程之间实现并发控制，还需要一个volatile的变量，boolean是原子性的变量。因此，一般的并发控制的操作逻辑如下所示：<br>\n\nvolatile boolean isProcess = false;<br>\nReentrantLock lock  = new ReentrantLock();<br>\nCondtion processReady = lock.newCondtion();<br>\nthread: run() {<br>\n   \nlock.lock();<br>\n    isProcess =\ntrue;<br>\n   try {<br>\n   \nwhile(!isProcessReady) {  //isProcessReady\n是另外一个线程的控制变量<br>\n     \nprocessReady.await();//释放了lock，在此等待signal<br>\n    \n}catch (InterruptedException e) {<br>\n         \nThread.currentThread().interrupt();<br>\n       \n} finally {<br>\n         \nlock.unlock();<br>\n         \nisProcess = false;<br>\n       \n}<br>\n     \n}<br>\n    }<br>\n}<br>\n看Hadoop的一段摘取的源码：\n<pre style=\"padding:1em;border:1px dashed rgb(47,111,171);color:black;background-color:rgb(249,249,249);line-height:1.1em\">\n\n<br>\n<br>\nprivate class MapOutputBuffer&lt;K extends Object, V extends Object&gt;<br>\n      implements MapOutputCollector&lt;K, V&gt;, IndexedSortable {<br>\n...<br>\n    boolean spillInProgress; <br>\n    final ReentrantLock spillLock = new ReentrantLock();<br>\n    final Condition spillDone = spillLock.newCondition();<br>\n    final Condition spillReady = spillLock.newCondition();<br>\n    volatile boolean spillThreadRunning = false;<br>\n    final SpillThread spillThread = new SpillThread();<br>\n...<br>\n    public MapOutputBuffer(TaskUmbilicalProtocol umbilical, JobConf job,<br>\n                           TaskReporter reporter<br>\n                           ) throws IOException, ClassNotFoundException {<br>\n    ...<br>\n      spillInProgress = false;<br>\n      spillThread.setDaemon(true);<br>\n      spillThread.setName(&quot;SpillThread&quot;);<br>\n      spillLock.lock();<br>\n      try {<br>\n        spillThread.start();<br>\n        while (!spillThreadRunning) {<br>\n          spillDone.await();<br>\n        }<br>\n      } catch (InterruptedException e) {<br>\n        throw new IOException(&quot;Spill thread failed to initialize&quot;, e);<br>\n      } finally {<br>\n        spillLock.unlock();<br>\n      }<br>\n    }<br>\n<br>\n    protected class SpillThread extends Thread {<br>\n<br>\n      @Override<br>\n      public void run() {<br>\n        spillLock.lock();<br>\n        spillThreadRunning = true;<br>\n        try {<br>\n          while (true) {<br>\n            spillDone.signal();<br>\n            while (!spillInProgress) {<br>\n              spillReady.await();<br>\n            }<br>\n            try {<br>\n              spillLock.unlock();<br>\n              sortAndSpill();<br>\n            } catch (Throwable t) {<br>\n              sortSpillException = t;<br>\n            } finally {<br>\n              spillLock.lock();<br>\n              if (bufend &lt; bufstart) {<br>\n                bufvoid = kvbuffer.length;<br>\n              }<br>\n              kvstart = kvend;<br>\n              bufstart = bufend;<br>\n              spillInProgress = false;<br>\n            }<br>\n          }<br>\n        } catch (InterruptedException e) {<br>\n          Thread.currentThread().interrupt();<br>\n        } finally {<br>\n          spillLock.unlock();<br>\n          spillThreadRunning = false;<br>\n        }<br>\n      }<br>\n    }\n</pre>"
    },
    "author" : "klose",
    "comments" : [ ],
    "annotations" : [ ],
    "origin" : {
      "streamId" : "feed/http://blog.sina.com.cn/rss/1243568575.xml",
      "title" : "klose的BLOG",
      "htmlUrl" : "http://blog.sina.com.cn/jiangbinglover"
    }
  }, {
    "isReadStateLocked" : true,
    "crawlTimeMsec" : "1361875627486",
    "timestampUsec" : "1361875627486503",
    "id" : "tag:google.com,2005:reader/item/6b36647feb7f6359",
    "categories" : [ "user/06079683711886564499/state/com.google/starred", "user/06079683711886564499/state/com.google/read" ],
    "title" : "Java Performance News January 2013",
    "published" : 1361875627,
    "updated" : 1361875627,
    "alternate" : [ {
      "href" : "http://www.JavaPerformanceTuning.com/news/news146.shtml",
      "type" : "text/html"
    } ],
    "summary" : {
      "direction" : "ltr",
      "content" : "We list all the latest Java performance related news and articles. \"I've categorised the first batch of the 600 java performance tools we've listed over the last 12 years\""
    },
    "comments" : [ ],
    "annotations" : [ ],
    "origin" : {
      "streamId" : "feed/http://www.javaperformancetuning.com/newsletters.rss",
      "title" : "JavaPerformanceTuning.com News",
      "htmlUrl" : "http://www.JavaPerformanceTuning.com/newsletter.shtml"
    }
  }, {
    "isReadStateLocked" : true,
    "crawlTimeMsec" : "1361875617045",
    "timestampUsec" : "1361875617045460",
    "id" : "tag:google.com,2005:reader/item/5f3a409929adb99e",
    "categories" : [ "user/06079683711886564499/state/com.google/read", "user/06079683711886564499/state/com.google/starred" ],
    "title" : "January 2013 New Java Performance Tips",
    "published" : 1361875617,
    "updated" : 1361875617,
    "alternate" : [ {
      "href" : "http://www.javaperformancetuning.com/news/newtips146.shtml",
      "type" : "text/html"
    } ],
    "summary" : {
      "direction" : "ltr",
      "content" : "The latest Java performance tips from around the web, such as \"There is a difference between design optimization and code optimization - optimization is usually necessary at the design phase, and is not premature; not optimizing at the design phase can easily lead to bad architecture.\" and \"Appropriate choices of data structures and algorithms are optimisations that are NOT premature.\""
    },
    "comments" : [ ],
    "annotations" : [ ],
    "origin" : {
      "streamId" : "feed/http://www.javaperformancetuning.com/newsletters.rss",
      "title" : "JavaPerformanceTuning.com News",
      "htmlUrl" : "http://www.JavaPerformanceTuning.com/newsletter.shtml"
    }
  }, {
    "isReadStateLocked" : true,
    "crawlTimeMsec" : "1361875526898",
    "timestampUsec" : "1361875526898508",
    "id" : "tag:google.com,2005:reader/item/d8c4e0b9fa693861",
    "categories" : [ "user/06079683711886564499/state/com.google/read", "user/06079683711886564499/state/com.google/starred", "Security", "Android 4.2" ],
    "title" : "Using Cryptography to Store Credentials Safely",
    "published" : 1361306760,
    "updated" : 1361843613,
    "canonical" : [ {
      "href" : "http://android-developers.blogspot.com/2013/02/using-cryptography-to-store-credentials.html"
    } ],
    "alternate" : [ {
      "href" : "http://feedproxy.google.com/~r/blogspot/hsDu/~3/PEbXoBLScqY/using-cryptography-to-store-credentials.html",
      "type" : "text/html"
    } ],
    "content" : {
      "direction" : "ltr",
      "content" : "<p><em>Posted by <a href=\"https://plus.google.com/114249855229891870149\">Trevor Johns</a>, Android Developer Relations team</em></p><div style=\"float:right;padding-right:0\"><img src=\"http://3.bp.blogspot.com/-m9OjYhySVW8/URwiN1hR-cI/AAAAAAAAB8o/0aTXDBZT2NQ/s400/Random-Droid.png\" alt=\"random_droid\" width=\"190\" style=\"margin-bottom:0;margin-right:1em;padding:0 1.5em 1.5em 1.5em\">\n</div>\n\n<p>Following our talk <a href=\"https://developers.google.com/events/io/sessions/gooio2012/107/\">\"Security and Privacy in Android Apps\"</a> at Google I/O last year, many people had specific questions about how to use cryptography in Android. Many of those revolved around which APIs to use for a specific purpose. Let's look at how to use cryptography to safely store user credentials, such as passwords and auth tokens, on local storage.</p>\n\n<h3>An anti-pattern</h3>\n\n<p>A common (but incorrect) pattern that we've recently become aware of is to use <code><a href=\"http://developer.android.com/reference/java/security/SecureRandom.html\">SecureRandom</a></code> as a means of generating deterministic key material, which would then be used to encrypt local credential caches. Examples are not hard to find, such as <a href=\"http://www.androidsnippets.com/encryptdecrypt-strings\">here</a>, <a href=\"http://stackoverflow.com/questions/13433529/android-4-2-broke-my-encrypt-decrypt-code-and-the-provided-solutions-dont-work\">here</a>, <a href=\"http://stackoverflow.com/questions/13383006/encryption-error-on-android-4-2\">here</a>, and elsewhere.</p>\n\n<p>In this pattern, rather than storing an encryption key directly as a string inside an APK, the code uses a proxy string to generate the key instead — similar to a passphrase. This essentially obfuscates the key so that it&#39;s not readily visible to attackers. However, a skilled attacker would be able to easily see around this strategy. We don&#39;t recommend it.</p>\n\n<p>The fact is, Android's existing security model already provides plenty of protection for this kind of data. User credentials should be stored with the <code><a href=\"http://developer.android.com/reference/android/content/Context.html#MODE_PRIVATE\">MODE_PRIVATE</a></code> flag set and stored in internal storage, rather than on an SD card, since permissions aren't enforced on external storage. Combined with device encryption, this provides protection from most types of attacks targeting credentials.</p>\n\n<p>However, there's another problem with using <code>SecureRandom</code> in the way described above. Starting with Android 4.2, the default \n<code>SecureRandom</code> provider is OpenSSL, and a developer can no longer override <code>SecureRandom</code>’s internal state.  Consider the following code:</p>\n\n<pre>\n  SecureRandom secureRandom = new SecureRandom();\n  byte[] b = new byte[] { (byte) 1 };\n  secureRandom.setSeed(b);\n  // Prior to Android 4.2, the next line would always return the same number!\n  System.out.println(secureRandom.nextInt());\n</pre>\n\n<p>The old Bouncy Castle-based implementation allowed overriding the internally generated, /dev/urandom based key for each <code>SecureRandom</code> instance. Developers which attempted to explicitly seed the random number generator would find that their seed replaces, not supplements, the existing seed (contrary to the <a href=\"http://developer.android.com/reference/java/security/SecureRandom.html#insecure_seed\">reference implementation’s documentation</a>). Under OpenSSL, this error-prone behavior is no longer possible.</p>\n\n<p>Unfortunately, applications who relied on the old behavior will find that the output from <code>SecureRandom</code> changes randomly every time their application starts up. (This is actually a very desirable trait for a random number generator!) Attempting to obfuscate encryption keys in this manner will no longer work.</p>\n\n<h3>The right way</h3>\n\n<p>A more reasonable approach is simply to generate a truly random AES key when an application is first launched:</p>\n\n<pre>public static SecretKey generateKey() throws NoSuchAlgorithmException {\n    // Generate a 256-bit key\n    final int outputKeyLength = 256;\n\n    SecureRandom secureRandom = new SecureRandom();\n    // Do *not* seed secureRandom! Automatically seeded from system entropy.\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n    keyGenerator.init(outputKeyLength, secureRandom);\n    SecretKey key = keyGenerator.generateKey();\n    return key;\n}</pre>\n\n<p>Note that the security of this approach relies on safeguarding the generated key, which is is predicated on the security of the internal storage. Leaving the target file unencrypted (but set to <code>MODE_PRIVATE</code>) would provide similar security.</p>\n\n<h3>Even more security</h3>\n\n<p>If your app needs additional encryption, a recommended approach is to require a passphase or PIN to access your application. This passphrase could be fed into PBKDF2 to generate the encryption key. (PBKDF2 is a commonly used algorithm for deriving key material from a passphrase, using a technique known as \"key stretching\".) Android provides an implementation of this algorithm inside <code><a href=\"http://developer.android.com/reference/javax/crypto/SecretKeyFactory.html\">SecretKeyFactory</a></code> as <code>PBKDF2WithHmacSHA1</code>:</p>\n\n<pre>public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {\n    // Number of PBKDF2 hardening rounds to use. Larger values increase\n    // computation time. You should select a value that causes computation\n    // to take &gt;100ms.\n    final int iterations = 1000; \n\n    // Generate a 256-bit key\n    final int outputKeyLength = 256;\n\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA1&quot;);\n    KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);\n    SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);\n    return secretKey;\n}</pre>\n\n<p>The salt should be a random string, again generated using <code>SecureRandom</code> and persisted on internal storage alongside any encrypted data. This is important to mitigate the risk of attackers using a rainbow table to precompute password hashes.</p>\n\n<h3>Check your apps for proper use of SecureRandom</h3>\n\n<p>As mentioned above and in the <a href=\"http://android-developers.blogspot.com/2013/02/security-enhancements-in-jelly-bean.html\">New Security Features in Jelly Bean</a>, the default implementation of <code>SecureRandom</code> is changed in Android 4.2. Using it to deterministically generate keys is no longer possible.</p>\n\n<p>If you're one of the developers who's been generating keys the wrong way, we recommend upgrading your app today to prevent subtle problems as more users upgrade to devices running Android 4.2 or later.</p>\n<div style=\"display:inline-block;float:right;line-height:0\"><div style=\"float:left\"><a href=\"https://plus.google.com/+AndroidDevelopers/posts/D4xXiPUFoRG\" style=\"color:#333333;text-decoration:none\"><span style=\"font:13px/16px arial,sans-serif;margin-right:4px;margin-top:0px\">Join the discussion on</span></a><br>\n<br>\n<a href=\"https://plus.google.com/+AndroidDevelopers/posts/D4xXiPUFoRG\" style=\"color:#333333;text-decoration:none\"><span style=\"font:bold 13px/16px arial,sans-serif;margin-right:4px;margin-top:7px\">+Android Developers</span></a></div><div style=\"float:right\"><a href=\"https://plus.google.com/+AndroidDevelopers/posts/D4xXiPUFoRG\" style=\"color:#333333;text-decoration:none\"><img height=\"32\" src=\"https://ssl.gstatic.com/images/icons/gplus-32.png\" style=\"border:0\" width=\"32\"></a></div></div><div>\n<a href=\"http://feeds.feedburner.com/~ff/blogspot/hsDu?a=PEbXoBLScqY:tnk_M7xDSxs:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/blogspot/hsDu?d=yIl2AUoC8zA\" border=\"0\"></a> <a href=\"http://feeds.feedburner.com/~ff/blogspot/hsDu?a=PEbXoBLScqY:tnk_M7xDSxs:-BTjWOF_DHI\"><img src=\"http://feeds.feedburner.com/~ff/blogspot/hsDu?i=PEbXoBLScqY:tnk_M7xDSxs:-BTjWOF_DHI\" border=\"0\"></a>\n</div><img src=\"http://feeds.feedburner.com/~r/blogspot/hsDu/~4/PEbXoBLScqY\" height=\"1\" width=\"1\">"
    },
    "author" : "Android Developers",
    "comments" : [ ],
    "annotations" : [ ],
    "origin" : {
      "streamId" : "feed/http://feeds.feedburner.com/blogspot/hsDu",
      "title" : "Android Developers Blog",
      "htmlUrl" : "http://android-developers.blogspot.com/"
    }
  }, {
    "isReadStateLocked" : true,
    "crawlTimeMsec" : "1361681033655",
    "timestampUsec" : "1361681033655858",
    "id" : "tag:google.com,2005:reader/item/25595c87ead2b822",
    "categories" : [ "user/06079683711886564499/state/com.google/read", "user/06079683711886564499/state/com.google/starred" ],
    "title" : "Zapping Android's Speedy Cycle",
    "published" : 1361569380,
    "updated" : 1361569380,
    "alternate" : [ {
      "href" : "http://www.drdobbs.com/cloud/zapping-androids-speedy-cycle/240149258",
      "type" : "text/html"
    } ],
    "summary" : {
      "direction" : "ltr",
      "content" : "Electric Cloud promises up to 75 percent faster software delivery times"
    },
    "comments" : [ ],
    "annotations" : [ ],
    "origin" : {
      "streamId" : "feed/http://www.drdobbs.com/news/cloud/rss",
      "title" : "Dr. Dobb&#39;s Cloud News",
      "htmlUrl" : "http://www.drdobbs.com//cloud"
    }
  } ]
}